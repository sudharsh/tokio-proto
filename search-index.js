var searchIndex = {};
searchIndex["tokio_proto"] = {"doc":"A collection of components for rapid protocol development","items":[[3,"Body","tokio_proto","Body stream",null,null],[4,"Error","","Error returned as an Error frame or an `io::Error` that occurerred during\nnormal processing of the Transport",null,null],[13,"Transport","","Transport frame level error",0,null],[13,"Io","","I/O level error",0,null],[4,"Message","","Message sent and received from a multiplexed service",null,null],[13,"WithoutBody","","Has no associated streaming body",1,null],[13,"WithBody","","Has associated streaming body",1,null],[0,"client","","Utilities for building protocol clients",null,null],[3,"Client","tokio_proto::client","Client `Service` for pipeline or multiplex protocols",null,null],[3,"Response","","Response future returned from a client",null,null],[5,"pair","","Return a client handle and a handle used to receive requests on",null,{"inputs":[],"output":{"name":"pair"}}],[6,"Pair","","A client / receiver pair",null,null],[6,"Receiver","","Receive requests submitted to the client",null,null],[11,"call","","",2,null],[11,"poll_ready","","",2,null],[11,"poll","","",3,null],[0,"multiplex","tokio_proto","Dispatch for multiplexed protocols",null,null],[3,"Multiplex","tokio_proto::multiplex","Task that drives multiplexed protocols",null,null],[3,"MultiplexMessage","","Message used to communicate through the multiplex dispatch",null,null],[12,"id","","Request ID",4,null],[12,"message","","Message",4,null],[12,"solo","","True if message has no pair (request / response)",4,null],[3,"Server","","A server `Task` that dispatches `Transport` messages to a `Service` using\nprotocol multiplexing.",null,null],[4,"Frame","","A multiplexed protocol frame",null,null],[13,"Message","","Either a request or a response.",5,null],[12,"id","tokio_proto::multiplex::Frame","Message exchange identifier",5,null],[12,"message","","The message value",5,null],[12,"body","","Set to true when body frames will follow with the same request ID.",5,null],[12,"solo","","Set to `true` when this message does not have a pair in the other\ndirection",5,null],[13,"Body","tokio_proto::multiplex","Body frame.",5,null],[12,"id","tokio_proto::multiplex::Frame","Message exchange identifier",5,null],[12,"chunk","","Body chunk. Setting to `None` indicates that the body is done\nstreaming and there will be no further body frames sent with the\ngiven request ID.",5,null],[13,"Error","tokio_proto::multiplex","Error",5,null],[12,"id","tokio_proto::multiplex::Frame","Message exchange identifier",5,null],[12,"error","","Error value",5,null],[13,"Done","tokio_proto::multiplex","Final frame sent in each transport direction",5,null],[5,"connect","","Connect to the given `addr` and handle using the given Transport and protocol pipelining.",null,{"inputs":[{"name":"t"},{"name":"handle"}],"output":{"name":"client"}}],[11,"new","","Create a new pipeline `Multiplex` dispatcher with the given service and\ntransport",6,{"inputs":[{"name":"t"}],"output":{"name":"multiplex"}}],[11,"poll","","",6,null],[11,"drop","","",6,null],[11,"new","","Create a new MultiplexMessage",4,{"inputs":[{"name":"requestid"},{"name":"message"}],"output":{"name":"multiplexmessage"}}],[11,"error","","Create a new errored MultiplexMessage",4,{"inputs":[{"name":"requestid"},{"name":"e"}],"output":{"name":"multiplexmessage"}}],[11,"new","","Create a new pipeline `Server` dispatcher with the given service and\ntransport",7,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"server"}}],[11,"poll","","",7,null],[6,"RequestId","","Identifies a request / response thread",null,null],[8,"Dispatch","","Dispatch messages from the transport to the service",null,null],[16,"In","","Messages written to the transport",8,null],[16,"BodyIn","","Inbound body frame",8,null],[16,"Out","","Messages read from the transport",8,null],[16,"BodyOut","","Outbound body frame",8,null],[16,"Error","","Transport error",8,null],[16,"Stream","","Inbound body stream type",8,null],[16,"Transport","","Transport type",8,null],[10,"transport","","Mutable reference to the transport",8,null],[10,"poll","","Poll the next available message",8,null],[10,"poll_ready","","The `Dispatch` is ready to accept another message",8,null],[10,"dispatch","","Process an out message",8,null],[10,"cancel","","Cancel interest in the exchange identified by RequestId",8,null],[8,"Transport","","A specialization of `io::Transport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",9,null],[16,"BodyIn","","Inbound body frame",9,null],[16,"Out","","Messages read from the transport",9,null],[16,"BodyOut","","Outbound body frame",9,null],[16,"Error","","Transport error",9,null],[10,"poll_read","","Tests to see if this Transport may be readable.",9,null],[10,"read","","Read a message from the `Transport`",9,null],[10,"poll_write","","Tests to see if this I/O object may be writable.",9,null],[10,"write","","Write a message to the `Transport`",9,null],[10,"flush","","Flush pending writes to the socket",9,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"request_id","","Return the request ID associated with the frame.",5,null],[11,"unwrap_msg","","Unwraps a frame, yielding the content of the `Message`.",5,null],[11,"unwrap_body","","Unwraps a frame, yielding the content of the `Body`.",5,null],[11,"unwrap_err","","Unwraps a frame, yielding the content of the `Error`.",5,null],[11,"is_done","","Returns true if the frame is `Frame::Done`",5,null],[0,"pipeline","tokio_proto","A dispatcher for pipelining protocols",null,null],[3,"Pipeline","tokio_proto::pipeline","Provides protocol pipelining functionality in a generic way over clients\nand servers. Used internally by `pipeline::Client` and `pipeline::Server`.",null,null],[3,"Server","","A server `Task` that dispatches `Transport` messages to a `Service` using\nprotocol pipelining.",null,null],[4,"Frame","","A pipelined protocol frame",null,null],[13,"Message","","Either a request or a response",10,null],[12,"message","tokio_proto::pipeline::Frame","The message value",10,null],[12,"body","","Set to true when body frames will follow",10,null],[13,"Body","tokio_proto::pipeline","Body frame. None indicates that the body is done streaming.",10,null],[12,"chunk","tokio_proto::pipeline::Frame","Body chunk. Setting to `None` indicates that the body is done\nstreaming and there will be no further body frames sent with the\ngiven request ID.",10,null],[13,"Error","tokio_proto::pipeline","Error",10,null],[12,"error","tokio_proto::pipeline::Frame","Error value",10,null],[13,"Done","tokio_proto::pipeline","Final frame sent in each transport direction",10,null],[5,"connect","","Connect to the given `addr` and handle using the given Transport and protocol pipelining.",null,{"inputs":[{"name":"f"},{"name":"handle"}],"output":{"name":"client"}}],[11,"new","","Create a new pipeline `Server` dispatcher with the given service and\ntransport",11,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"server"}}],[11,"poll","","",11,null],[11,"new","","Create a new pipeline `Pipeline` dispatcher with the given service and\ntransport",12,{"inputs":[{"name":"t"}],"output":{"name":"pipeline"}}],[11,"poll","","",12,null],[6,"PipelineMessage","","Message used to communicate through the multiplex dispatch",null,null],[8,"Dispatch","","Dispatch messages from the transport to the service",null,null],[16,"In","","Message written to transport",13,null],[16,"BodyIn","","Body written to transport",13,null],[16,"Out","","Messages read from the transport",13,null],[16,"BodyOut","","Outbound body frame",13,null],[16,"Error","","Transport error",13,null],[16,"Stream","","Body stream written to transport",13,null],[16,"Transport","","Transport type",13,null],[10,"transport","","Mutable reference to the transport",13,null],[10,"dispatch","","Process an out message",13,null],[10,"poll","","Poll the next completed message",13,null],[10,"has_in_flight","","RPC currently in flight\nTODO: Get rid of",13,null],[8,"Transport","","A specialization of `io::Transport` supporting the requirements of\npipeline based protocols.",null,null],[16,"In","","Messages written to the transport",14,null],[16,"BodyIn","","Inbound body frame",14,null],[16,"Out","","Messages read from the transport",14,null],[16,"BodyOut","","Outbound body frame",14,null],[16,"Error","","Transport error",14,null],[10,"poll_read","","Tests to see if this Transport may be readable.",14,null],[10,"read","","Read a message from the `Transport`",14,null],[10,"poll_write","","Tests to see if this I/O object may be writable.",14,null],[10,"write","","Write a message to the `Transport`",14,null],[10,"flush","","Flush pending writes to the socket",14,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"unwrap_msg","","Unwraps a frame, yielding the content of the `Message`.",10,null],[11,"unwrap_body","","Unwraps a frame, yielding the content of the `Body`.",10,null],[11,"unwrap_err","","Unwraps a frame, yielding the content of the `Error`.",10,null],[11,"is_done","","Returns true if the frame is `Frame::Done`",10,null],[0,"server","tokio_proto","A generic Tokio TCP server implementation.",null,null],[3,"ServerHandle","tokio_proto::server","A handle to a running server.",null,null],[5,"listen","","Spawn a new `Task` that binds to the given `addr` then accepts all incoming\nconnections; dispatching them to tasks created by `new_task`.",null,{"inputs":[{"name":"handle"},{"name":"socketaddr"},{"name":"t"}],"output":{"name":"result"}}],[8,"NewTask","","Create a new `Task` to handle a server socket.",null,null],[16,"Item","","The `Task` value created by this factory",15,null],[10,"new_task","","Create and return a new `Task` value",15,null],[11,"local_addr","","Returns the local socket address of the `TcpListener` for this server.",16,null],[0,"easy","tokio_proto","&quot;Easy&quot; and simplified interfaces to tokio-proto APIs.",null,null],[3,"EasyClient","tokio_proto::easy","A client which does not support streaming bodies.",null,null],[3,"EasyResponse","","Future returned from `Client::call`.",null,null],[0,"multiplex","","An &quot;easy&quot; multiplexing module",null,null],[3,"EasyServer","tokio_proto::easy::multiplex","An &quot;easy&quot; multiplexed server.",null,null],[5,"connect","","The &quot;easy&quot; form of connecting a multiplexed client.",null,{"inputs":[{"name":"f"},{"name":"handle"}],"output":{"name":"easyclient"}}],[11,"new","","Instantiates a new multiplexed server.",17,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"easyserver"}}],[11,"poll","","",17,null],[0,"pipeline","tokio_proto::easy","An &quot;easy&quot; pipelining module",null,null],[3,"EasyServer","tokio_proto::easy::pipeline","An &quot;easy&quot; pipelined server.",null,null],[5,"connect","","The &quot;easy&quot; form of connecting a pipelined client.",null,{"inputs":[{"name":"f"},{"name":"handle"}],"output":{"name":"easyclient"}}],[11,"new","","Instantiates a new pipelined server.",18,{"inputs":[{"name":"s"},{"name":"t"}],"output":{"name":"easyserver"}}],[11,"poll","","",18,null],[11,"call","tokio_proto::easy","",19,null],[11,"poll_ready","","",19,null],[11,"poll","","",20,null],[11,"empty","tokio_proto","Return an empty body stream",21,{"inputs":[],"output":{"name":"body"}}],[11,"pair","","Return a body stream with an associated sender half",21,null],[11,"poll","","",21,null],[11,"from","","",21,{"inputs":[{"name":"receiver"}],"output":{"name":"body"}}],[11,"fmt","","",21,null],[11,"fmt","","",0,null],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"cause","","",0,null],[11,"get_ref","","Returns a reference to the inner value",1,null],[11,"get_mut","","Returns a mutable reference to the inner value",1,null],[11,"into_inner","","Consumes the value and returns the inner value",1,null],[11,"take_body","","If the `Message` value has an associated body stream, return it. The\noriginal `Message` value will then become a `WithoutBody` variant.",1,null],[11,"eq","","",1,null],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"fmt","","",1,null],[8,"TryRead","","A refinement of `std::io::Read` for reading from non-blocking sources.",null,null],[10,"try_read","","Pull some bytes from this source into the specified buffer, returning\nhow many bytes were read.",22,null],[10,"read_buf","","Pull some bytes from this source into the specified `Buf`, returning\nhow many bytes were read.",22,null],[10,"try_read_buf","","Pull some bytes from this source into the specified `Buf`, returning\nhow many bytes were read.",22,null],[8,"TryWrite","","A refinement of `std::io::Write` for reading from non-blocking sources.",null,null],[10,"try_write","","Write a buffer into this object, returning how many bytes were written.",23,null],[10,"write_buf","","Write a `Buf` into this value, returning how many bytes were written.",23,null],[10,"try_write_buf","","Write a `Buf` into this object, returning how many bytes were written.",23,null],[10,"try_flush","","Try flushing the underlying IO",23,null]],"paths":[[4,"Error"],[4,"Message"],[3,"Client"],[3,"Response"],[3,"MultiplexMessage"],[4,"Frame"],[3,"Multiplex"],[3,"Server"],[8,"Dispatch"],[8,"Transport"],[4,"Frame"],[3,"Server"],[3,"Pipeline"],[8,"Dispatch"],[8,"Transport"],[8,"NewTask"],[3,"ServerHandle"],[3,"EasyServer"],[3,"EasyServer"],[3,"EasyClient"],[3,"EasyResponse"],[3,"Body"],[8,"TryRead"],[8,"TryWrite"]]};
initSearch(searchIndex);
